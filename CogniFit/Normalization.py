# -*- coding: utf-8 -*-
"""Normalization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17JMrm_ittTB9TyKOPjrh_7bS4xvhKj6T
"""

import pandas as pd
import numpy as np

# -------------------------------------------------------- 1. Read the Excel file ---------------------------------------------------------
file_path = '/content/k.xlsx'
df = pd.read_excel(file_path)

# ------------------------------------------------ 2. Normalization Functions (unchanged) -------------------------------------------------
def normalize_accuracy(value):
    return value

def normalize_error(value):
    return 100 - value

def normalize_response_time(value):
    return ((5000 - value) / 5000) * 100

def normalize_vwm_response_time(value):
    return ((5000 - value) / 5000) * 100

def normalize_vwm_accuracy(value):
    return value

def normalize_vwm_omission_errors(value):
    return (12 - value) / 12 * 100

def normalize_vwm_omission_errors_percentage(value):
    return 100 - value

def normalize_digit_span_avg_trials(value):
    return 100 - ((value - 1) / (2 - 1)) * 100

def normalize_digit_span_memory_span(value):
    return (value / 10) * 100

def normalize_digit_span_omission_errors(value):
    return 100 - value

def normalize_digit_span_response_time(value):
    return ((10000 - value) / 10000) * 100

def normalize_maze_additional_steps(value):
    return 100 - value

def normalize_maze_direct_score(value):
    return 100 - (value / 37) * 100

def normalize_maze_steps(value, max_steps):
    return 100 - (value / max_steps) * 100

def normalize_maze_completion_time(value):
    return 100 - (value / 120000) * 100

def normalize_maze_first_completion_time(value):
    return 100 - (value / 40000) * 100

def normalize_maze_second_completion_time(value):
    return 100 - (value / 80000) * 100

def normalize_maze_third_completion_time(value):
    return 100 - (value / 120000) * 100

def normalize_maze_completed(value):
    return (value / 3) * 100

def normalize_maze_additional_completed(value):
    return 100 - (value / 3) * 100

def normalize_maze_perfect_completed(value):
    return (value / 3) * 100

def normalize_maze_not_completed(value):
    return 100 - (value / 3) * 100

def normalize_maze_first_steps(value):
    return 100 - ((value - 17) / (40 - 17)) * 100

def normalize_maze_second_steps(value):
    return 100 - ((value - 25) / (60 - 25)) * 100

def normalize_maze_third_steps(value):
    return 100 - ((value - 35) / (90 - 35)) * 100

def normalize_vwms_avg_trials(value):
    return 100 - ((value - 1) / (2 - 1)) * 100

def normalize_vwms_memory_span(value):
    return (value / 10) * 100

def normalize_vwms_omission_errors(value):
    return 100 - ((value - 0) / (10 - 0)) * 100

def normalize_vwms_response_time(value):
    return ((10000 - value) / (10000 - 250)) * 100

def normalize_iort_inhibition_return_accuracy(value):
    return ((value + 100) / 200) * 100

def normalize_iort_inhibition_return_response_time(value):
    return ((5000 - value) / (5000 + 5000)) * 100

def normalize_iort_omission_errors(value):
    return 100 - ((value / 40) * 100)

def normalize_iort_omission_errors_percentage(value):
    return 100 - value

def normalize_iort_response_time(value):
    return ((5000 - value) / 5000) * 100

def normalize_sat_commission_errors_percentage(value):
    return 100 - value

def normalize_sat_completion_time(value):
    return 100 - ((value / 150000) * 100)

def normalize_sat_correct_trials_percentage(value):
    return value

def normalize_sat_omission_errors_percentage(value):
    return 100 - value

def normalize_sat_timeouts(value):
    return 100 - ((value / 5) * 100)

def normalize_sat_timeouts_percentage(value):
    return 100 - value

def normalize_eh_accuracy(value):
    return value

def normalize_eh_distance(value):
    return ((1200 - value) / 1200) * 100

def normalize_pvt_accuracy(value):
    return value

def normalize_pvt_commission_errors(value):
    return (8 - value) / 8 * 100

def normalize_pvt_omission_errors(value):
    return (24 - value) / 24 * 100

def normalize_pvt_omission_errors_percentage(value):
    return 100 - value

def normalize_pvt_response_time(value):
    return ((5000 - value) / 5000) * 100

# ---------------------------------------------- 3. Normalization Dictionaries (unchanged) ------------------------------------------------
normalization_functions_vwm = {
    'Accuracy': normalize_vwm_accuracy,
    'Accuracy in long distance': normalize_vwm_accuracy,
    'Accuracy in long exposure time': normalize_vwm_accuracy,
    'Accuracy in medium exposure time': normalize_vwm_accuracy,
    'Accuracy in medium-long distance': normalize_vwm_accuracy,
    'Accuracy in medium-short distance': normalize_vwm_accuracy,
    'Accuracy in short distance': normalize_vwm_accuracy,
    'Accuracy in short exposure time': normalize_vwm_accuracy,
    'Omission errors': normalize_vwm_omission_errors,
    'Omission errors (percentage)': normalize_vwm_omission_errors_percentage,
    'Response time': normalize_vwm_response_time,
    'Response time in long distance': normalize_vwm_response_time,
    'Response time in long exposure time': normalize_vwm_response_time,
    'Response time in medium exposure time': normalize_vwm_response_time,
    'Response time in medium-long distance': normalize_vwm_response_time,
    'Response time in medium-short distance': normalize_vwm_response_time,
    'Response time in short distance': normalize_vwm_response_time,
    'Response time in short exposure time': normalize_vwm_response_time,
}

normalization_functions_digit_span = {
    'Average number of trials in correct series': normalize_digit_span_avg_trials,
    'Memory span': normalize_digit_span_memory_span,
    'Omission errors': normalize_digit_span_omission_errors,
    'Response time': normalize_digit_span_response_time,
}

normalization_functions_maze = {
    'Additional steps': normalize_maze_additional_steps,
    'Additional steps (direct score)': normalize_maze_direct_score,
    'Additional steps in first maze': lambda x: normalize_maze_steps(x, 23),
    'Additional steps in second maze': lambda x: normalize_maze_steps(x, 35),
    'Additional steps in third maze': lambda x: normalize_maze_steps(x, 55),
    'Completion time': normalize_maze_completion_time,
    'Completion time in first maze': normalize_maze_first_completion_time,
    'Completion time in second maze': normalize_maze_second_completion_time,
    'Completion time in third maze': normalize_maze_third_completion_time,
    'Mazes completed': normalize_maze_completed,
    'Mazes completed with additional steps': normalize_maze_additional_completed,
    'Mazes completed without additional steps': normalize_maze_perfect_completed,
    'Mazes not completed due to reaching max steps': normalize_maze_not_completed,
    'Omission errors': normalize_maze_first_steps,
    'Steps in first maze': normalize_maze_first_steps,
    'Steps in second maze': normalize_maze_second_steps,
    'Steps in third maze': normalize_maze_third_steps,
}

normalization_functions_vwms = {
    'Average number of trials in correct series': normalize_vwms_avg_trials,
    'Memory span': normalize_vwms_memory_span,
    'Memory span in Phase 1': normalize_vwms_memory_span,
    'Memory span in Phase 2': normalize_vwms_memory_span,
    'Omission errors': normalize_vwms_omission_errors,
    'Response time': normalize_vwms_response_time,
}

normalization_functions_iort = {
    'Accuracy': normalize_accuracy,
    'Accuracy in cued trials': normalize_accuracy,
    'Accuracy in uncued trials': normalize_accuracy,
    'Inhibition of return effect in accuracy': normalize_iort_inhibition_return_accuracy,
    'Inhibition of return effect in response time': normalize_iort_inhibition_return_response_time,
    'Omision errors': normalize_iort_omission_errors,
    'Omission errors (percentage)': normalize_iort_omission_errors_percentage,
    'Omission errors in cued trials': normalize_iort_omission_errors,
    'Omission errors in cued trials (percentage)': normalize_iort_omission_errors_percentage,
    'Omission errors in uncued trials': normalize_iort_omission_errors,
    'Omission errors in uncued trials (percentage)': normalize_iort_omission_errors_percentage,
    'Response time': normalize_iort_response_time,
    'Response time in cued trials': normalize_iort_response_time,
    'Response time in uncued trials': normalize_iort_response_time,
}

normalization_functions_sat = {
    'Accuracy': normalize_accuracy,
    'Commission errors (percentage)': normalize_sat_commission_errors_percentage,
    'Completion time': normalize_sat_completion_time,
    'Correct trials (percentage)': normalize_sat_correct_trials_percentage,
    'Omission errors (percentage)': normalize_sat_omission_errors_percentage,
    'Timeouts': normalize_sat_timeouts,
    'Timeouts (percentage)': normalize_sat_timeouts_percentage,
}

normalization_functions_eh_mud = {
    'Accuracy': normalize_eh_accuracy,
    'Accuracy in fast speed': normalize_eh_accuracy,
    'Accuracy in long segments duration': normalize_eh_accuracy,
    'Accuracy in short segments duration': normalize_eh_accuracy,
    'Accuracy in slow speed': normalize_eh_accuracy,
    'Distance from the ball center': normalize_eh_distance,
}

normalization_functions_eh_ftud = {
    'Accuracy': normalize_eh_accuracy,
    'Accuracy in fast speed': normalize_eh_accuracy,
    'Accuracy in long segments duration': normalize_eh_accuracy,
    'Accuracy in short segments duration': normalize_eh_accuracy,
    'Accuracy in slow speed': normalize_eh_accuracy,
    'Distance from the ball center': normalize_eh_distance,
}

normalization_functions_pvt = {
    'Accuracy': normalize_pvt_accuracy,
    'Accuracy in high demand': normalize_pvt_accuracy,
    'Accuracy in low demand': normalize_pvt_accuracy,
    'Commission errors': normalize_pvt_commission_errors,
    'Omission errors': normalize_pvt_omission_errors,
    'Omission errors (percentage)': normalize_pvt_omission_errors_percentage,
    'Omission errors in high demand': normalize_pvt_omission_errors,
    'Omission errors in low demand': normalize_pvt_omission_errors,
    'Response time': normalize_pvt_response_time,
    'Response time in high demand': normalize_pvt_response_time,
    'Response time in low demand': normalize_pvt_response_time,
}

# ----------------------------------------------- 4. Convert the 'value' column to numeric ------------------------------------------------
df['value'] = pd.to_numeric(df['value'], errors='coerce')

# -------------------------------------- 5. Normalize the values based on the task name and variable --------------------------------------
def normalize_value(row):
    task_name = row['task_name']
    variable = row['variable']
    value = row['value']

    if task_name == 'Visual Memory Test' and variable in normalization_functions_vwm:
        return normalization_functions_vwm[variable](value)
    elif task_name == 'Digit Span Test' and variable in normalization_functions_digit_span:
        return normalization_functions_digit_span[variable](value)
    elif task_name == 'Maze Test' and variable in normalization_functions_maze:
        return normalization_functions_maze[variable](value)
    elif task_name == 'Visual Working Memory Span Test' and variable in normalization_functions_vwms:
        return normalization_functions_vwms[variable](value)
    elif task_name == 'Inhibition of Return Test' and variable in normalization_functions_iort:
        return normalization_functions_iort[variable](value)
    elif task_name == 'Selective Attention Test' and variable in normalization_functions_sat:
        return normalization_functions_sat[variable](value)
    elif task_name == 'Eye-Hand Coordination Test (MUD)' and variable in normalization_functions_eh_mud:
        return normalization_functions_eh_mud[variable](value)
    elif task_name == 'Eye-Hand Coordination Test (FTUD)' and variable in normalization_functions_eh_ftud:
        return normalization_functions_eh_ftud[variable](value)
    elif task_name == 'Psychomotor Vigilance Test' and variable in normalization_functions_pvt:
        return normalization_functions_pvt[variable](value)
    else:
        return value

df['Normalized Value'] = df.apply(normalize_value, axis=1)

# ----------------------------------------------- 6. Calculate final results for each task ------------------------------------------------
task_final_result_columns = {}
for task in df['task_name'].unique():
    task_df = df[df['task_name'] == task]
    final_result = task_df['Normalized Value'].mean()
    column_name = f'Final Result {task}'
    df.loc[df['task_name'] == task, column_name] = final_result
    task_final_result_columns[task] = column_name
    print(f"Final Result for {task}: {final_result}")

# ------------------------------------------------ 7. Calculate the overall 'Final Result' ------------------------------------------------
columns_to_average = list(task_final_result_columns.values())

# Calculate the average of the columns and ignore NaN values
df['Final Result'] = df[columns_to_average].mean(axis=1, skipna=True)

# ----------------------------------------- 8. Calculate the average of the 'Final Result' column -----------------------------------------
final_result_mean = df['Final Result'].mean()

print(f"Average of the 'Final Result' column: {final_result_mean:.2f}")

# ------------------------------------- 9. Add the average as a new row at the end of the Excel file --------------------------------------
new_row = pd.DataFrame({'Final Result': [final_result_mean]}, index=['Average'])
df = pd.concat([df, new_row])

# -------------------------------------------------- 10. Save results in a new Excel file -------------------------------------------------
output_file = '/content/normalized_results_with_final_and_average.xlsx'
df.to_excel(output_file, index=True)

print("Operation completed successfully. Results saved in 'normalized_results_with_final_and_average.xlsx'.")

# ------------------------------------------ 11. Download output file in Google Colab (optional) ------------------------------------------
from google.colab import files
files.download(output_file)